/* Main.c file generated by New Project wizard
 *
 * Created:   Tue Apr 7 2020
 * Processor: PIC16F887
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
//#include "i2c.h"
//#include "ds3231.h"
//#include "lcd.h"


__PROG_CONFIG(1,0x20D4); 	// config. uC 
__PROG_CONFIG(2,0x0000); 	// config. uC 
 #define _XTAL_FREQ 8000000

//Define Buttons
#define MB RB1//The middle button 
#define LB RB4//Left button 
#define RB RB2//Right button 
#define UB RB0 //Upper Button 
#define BB RB3 //Bottom button 

//Define Buzz
#define BUZZ RB5 //Buzzer is connected to RD1

void initialize (void);
void I2C_Hold(void);
void I2C_Begin(void);
void I2C_End(void);
void I2C_Write(int data);
unsigned short I2C_Read(unsigned short ack);
void init_LCD(void);
void lcd_write(unsigned char c);
void lcd_clear(void);
void lcd_goto(unsigned char pos);
void lcd_puts(char * s);
void lcd_putch(char c);
void delay_LCD(unsigned long t);
void initializare_diacritice(void);
void scrie_diacritice_in_CGRAM(char matrice[8], unsigned char pozitie_DDRAM,unsigned char *diacritic);
void afisare_diacritice(unsigned char diacritic_afisat, unsigned char linia);

int  BCD_2_DEC(int to_convert);
int DEC_2_BCD (int to_convert);
void Set_Time_Date(void);
void Update_Current_Date_Time(void);
//void interrupt etti(void); 

char *timelogo = (char *) "TIME:";
char *logortc1 = (char *) "Alarm Clock";
char *logortc2 = (char *) "using RTC";
char *alarmlogo = (char *) "Alarm:";
/*Set the current value of date and time below**/
int sec;
int min;
int hour;
int date;
int month;
int year;
/*Time and Date Set*/

/*Vars for Alarm clock*/
char set_alarm = 0;
char trigger_alarm = 0;
char pos = 8;
char jump = 0;

char alarm_h0 = 0;
char alarm_h1 = 0;
char alarm_m0 = 0;
char alarm_m1 = 0;
int alarm_val[4] = {0, 0, 0, 0};
/*End of var declaration*/

void main(void) 
{

    TRISD = 0x00; //Make Port D pins as outptu for LCD interfacing 
    TRISB = 0xFF; //Switchs are declared as input pins
    OPTION_REG = 0b00000000; //Enable pull up Resistor on port B for switchs
    BUZZ = 0; //Turn of buzzer

    //Lcd_Start(); // Initialize LCD module
	init_LCD();
    initialize(); //Initialize I2C Master with 100KHz clock

    //Remove the below line once time and date is set for the first time.
    //Set_Time_Date(); //set time and date on the RTC module 

    //Give an intro message on the LCD
         lcd_clear();
         lcd_goto(0x80);
         lcd_puts(logortc1);
         lcd_goto(0xC0);
         lcd_puts(logortc2);
         __delay_ms(500); 

    while (1) {

        Update_Current_Date_Time(); //Read the current date and time from RTC module

        //Split the into char to display on lcd
        char sec_0 = sec % 10;
        char sec_1 = (sec / 10);
        char min_0 = min % 10;
        char min_1 = min / 10;
        char hour_0 = hour % 10;
        char hour_1 = hour / 10;


        //Display the Current Time on the LCD screen
        lcd_clear();
        lcd_goto(0x80);
        lcd_puts(timelogo);
        lcd_putch(hour_1 + '0');
        lcd_putch(hour_0 + '0');
        lcd_putch(':');
        lcd_putch(min_1 + '0');
        lcd_putch(min_0 + '0');
        lcd_putch(':');
        lcd_putch(sec_1 + '0');
        lcd_putch(sec_0 + '0');



        //Display the Date on the LCD screen
        lcd_goto(0xC0);
        lcd_puts(alarmlogo);
        lcd_putch(alarm_val[0] + '0');
        lcd_putch(alarm_val[1] + '0');
        lcd_putch(':');
        lcd_putch(alarm_val[2] + '0');
        lcd_putch(alarm_val[3] + '0');

        __delay_ms(50);


        //Use middle button to check if alarm has to be set 
        if (MB == 0 && set_alarm == 0) { //If middle button is pressed and alarm is not turned on 
            while (!MB); //Wait till button is released
            set_alarm = 1; //start setting alarm value 
        }
        if (MB == 0 && set_alarm == 1) { //If middle button is pressed and alarm is not turned off 
            while (!MB); //Wait till button is released
            set_alarm = 0; //stop setting alarm value 
        }


        //If alarm has to be navigate through each digit
        if (set_alarm == 1) {
            if (LB == 0) { //If left button is pressed
                while (!LB); //Wait till button is released
                pos--; //Then move the cursor to left
            }
            if (RB == 0) { //If right button is pressed 
                while (!RB); //Wait till button is released
                pos++; //Move cursor to right
            }

            if (pos >= 10) //eliminate ":" symbol if cursor reaches there
            {
                jump = 1; //Jump over the ":" symbol 
            } else
                jump = 0; //get back to normal movement


            if (UB == 0) { //If upper button is pressed
                while (!UB); //Wait till button is released
                alarm_val[(pos - 8)]++; //Increase that particular char value 
            }
            if (BB == 0) { //If lower button is pressed
                while (!UB); //Wait till button is released
                alarm_val[(pos - 8)]--; //Decrease that particular char value 
            }

          /*  Lcd_Set_Cursor(2, pos + jump);
            Lcd_Print_Char(95); //Display "_" to indicate cursor position*/
        }

        //IF alarm is set Check if the set value is equal to current value 
        if (set_alarm == 0 && alarm_val[0] == hour_1 && alarm_val[1] == hour_0 && alarm_val[2] == min_1 && alarm_val[3] == min_0)
            trigger_alarm = 1; //Turn on trigger if value match

        
        if (trigger_alarm) { //If alarm is triggered 
            //Beep the buzzer
            BUZZ = 1; 
            __delay_ms(500);
            BUZZ = 0;
            __delay_ms(500);
        }

        __delay_ms(200);//Update interval 

    }
}



/****** Functions for RTC module *******/

int  BCD_2_DEC(int to_convert)
{
   return (to_convert >> 4) * 10 + (to_convert & 0x0F); 
}

int DEC_2_BCD (int to_convert)
{
   return ((to_convert / 10) << 4) + (to_convert % 10);
}

void Set_Time_Date(void)
{
   I2C_Begin();       
   I2C_Write(0xD0); 
   I2C_Write(0);  
   I2C_Write(DEC_2_BCD(sec)); //update sec
   I2C_Write(DEC_2_BCD(min)); //update min
   I2C_Write(DEC_2_BCD(hour)); //update hour
   I2C_Write(1); //ignore updating day
   I2C_Write(DEC_2_BCD(date)); //update date
   I2C_Write(DEC_2_BCD(month)); //update month
   I2C_Write(DEC_2_BCD(year)); //update year
   I2C_End();
}

void Update_Current_Date_Time()
{
   //START to Read
   I2C_Begin();       
   I2C_Write(0xD0); 
   I2C_Write(0);    
   I2C_End(); 
   
  //READ
   I2C_Begin();
   I2C_Write(0xD1);                              // Initialize data read
   sec = BCD_2_DEC(I2C_Read(1));    
   min = BCD_2_DEC(I2C_Read(1));   // Read sec from register 
   hour = BCD_2_DEC(I2C_Read(1));  
   I2C_Read(1);
   date = BCD_2_DEC(I2C_Read(1));  
   month = BCD_2_DEC(I2C_Read(1));  
   year = BCD_2_DEC(I2C_Read(1));  
   I2C_End(); 
    
  //END Reading  
    I2C_Begin();
    I2C_Write(0xD1);                              // Initialize data read
    I2C_Read(1);    
    I2C_End(); 

}

void initialize (void) //Begin IIC as master
{
  TRISC3 = 1;  
  TRISC4 = 1;  //Set SDA and SCL pins as input pins
  
  SSPCON  = 0b00101000;    //pg179/288
  SSPCON2 = 0b00000000;    //pg180/288
  SSPADD=19;
  //SSPADD = (_XTAL_FREQ/(4*feq*100))-1; //Setting Clock Speed pg193/234
  SSPSTAT = 0b00000000;    //pg185/288
}

void I2C_Hold(void)
{
    while (   (SSPCON2 & 0b00011111)    ||    (SSPSTAT & 0b00000100)   ) ; //check the bis on registers to make sure the IIC is not in progress
}

void I2C_Begin()
{
  I2C_Hold();  //Hold the program is I2C is busy  
  SEN = 1;     //Begin I2C pg180/288/
}



void I2C_End(void)
{
  I2C_Hold(); //Hold the program is I2C is busy  
  PEN = 1;    //End I2C pg180/288
}

void I2C_Write(int data)
{
  I2C_Hold(); //Hold the program is I2C is busy 
  SSPBUF = data;         //pg187/288
}

unsigned short I2C_Read(unsigned short ack)
{
  unsigned short incoming;
  I2C_Hold();
  RCEN = 1;
  
  I2C_Hold();
  incoming = SSPBUF;      //get the data saved in SSPBUF
  
  I2C_Hold();
  ACKDT = (ack)?0:1;    //check if ack bit received  
  ACKEN = 1;          //pg 180/288
  
  return incoming;
}

